/* Not a contribution
 * Changes made by NVIDIA CORPORATION & AFFILIATES enabling ryu or otherwise documented as
 * NVIDIA-proprietary are not a contribution and subject to the following terms and conditions:
 *
 * SPDX-FileCopyrightText: Copyright (c) 2023 NVIDIA CORPORATION & AFFILIATES. All rights reserved.
 * SPDX-License-Identifier: LicenseRef-NvidiaProprietary
 *
 * NVIDIA CORPORATION, its affiliates and licensors retain all intellectual
 * property and proprietary rights in and to this material, related
 * documentation and any modifications thereto. Any use, reproduction,
 * disclosure or distribution of this material and related documentation
 * without an express license agreement from NVIDIA CORPORATION or
 * its affiliates is strictly prohibited.
 */

#include <cuda/std/climits>
#include <cuda/std/limits>
#include <cuda/std/type_traits>
#include <cuda/std/cassert>
#include <cuda/std/cstdint>

namespace spark_rapids_jni {

namespace detail {
namespace {

// A floating decimal representing m * 10^e.
typedef struct floating_decimal_64 {
  uint64_t mantissa;
  // Decimal exponent's range is -324 to 308
  // inclusive, and can fit in a short if needed.
  int32_t exponent;
} floating_decimal_64;

// A floating decimal representing m * 10^e.
typedef struct floating_decimal_32 {
  uint32_t mantissa;
  // Decimal exponent's range is -45 to 38
  // inclusive, and can fit in a short if needed.
  int32_t exponent;
} floating_decimal_32;

struct ftos_converter {

  // These tables are generated by PrintDoubleLookupTable.
  static constexpr unsigned int DOUBLE_POW5_INV_BITCOUNT = 125;
  static constexpr unsigned int DOUBLE_POW5_BITCOUNT = 125;
  static constexpr unsigned int FLOAT_POW5_INV_BITCOUNT = (DOUBLE_POW5_INV_BITCOUNT - 64);
  static constexpr unsigned int FLOAT_POW5_BITCOUNT = (DOUBLE_POW5_BITCOUNT - 64);
  static constexpr unsigned int DOUBLE_MANTISSA_BITS = 52;
  static constexpr unsigned int DOUBLE_EXPONENT_BITS = 11;
  static constexpr unsigned int DOUBLE_BIAS = 1023;
  static constexpr unsigned int FLOAT_MANTISSA_BITS = 23;
  static constexpr unsigned int FLOAT_EXPONENT_BITS = 8;
  static constexpr unsigned int FLOAT_BIAS = 127;


  // Returns the number of decimal digits in v, which must not contain more than 9 digits.
  __device__ inline uint32_t decimalLength9(const uint32_t v) {
    // Function precondition: v is not a 10-digit number.
    // (f2s: 9 digits are sufficient for round-tripping.)
    // (d2fixed: We print 9-digit blocks.)
    assert(v < 1000000000);
    if (v >= 100000000) { return 9; }
    if (v >= 10000000) { return 8; }
    if (v >= 1000000) { return 7; }
    if (v >= 100000) { return 6; }
    if (v >= 10000) { return 5; }
    if (v >= 1000) { return 4; }
    if (v >= 100) { return 3; }
    if (v >= 10) { return 2; }
    return 1;
  }

  const uint64_t DOUBLE_POW5_INV_SPLIT2[15][2] = {
    {                    1u, 2305843009213693952u },
    {  5955668970331000884u, 1784059615882449851u },
    {  8982663654677661702u, 1380349269358112757u },
    {  7286864317269821294u, 2135987035920910082u },
    {  7005857020398200553u, 1652639921975621497u },
    { 17965325103354776697u, 1278668206209430417u },
    {  8928596168509315048u, 1978643211784836272u },
    { 10075671573058298858u, 1530901034580419511u },
    {   597001226353042382u, 1184477304306571148u },
    {  1527430471115325346u, 1832889850782397517u },
    { 12533209867169019542u, 1418129833677084982u },
    {  5577825024675947042u, 2194449627517475473u },
    { 11006974540203867551u, 1697873161311732311u },
    { 10313493231639821582u, 1313665730009899186u },
    { 12701016819766672773u, 2032799256770390445u }
  };

  const uint32_t POW5_INV_OFFSETS[19] = {
    0x54544554, 0x04055545, 0x10041000, 0x00400414, 0x40010000, 0x41155555,
    0x00000454, 0x00010044, 0x40000000, 0x44000041, 0x50454450, 0x55550054,
    0x51655554, 0x40004000, 0x01000001, 0x00010500, 0x51515411, 0x05555554,
    0x00000000
  };

  const uint64_t DOUBLE_POW5_SPLIT2[13][2] = {
    {                    0u, 1152921504606846976u },
    {                    0u, 1490116119384765625u },
    {  1032610780636961552u, 1925929944387235853u },
    {  7910200175544436838u, 1244603055572228341u },
    { 16941905809032713930u, 1608611746708759036u },
    { 13024893955298202172u, 2079081953128979843u },
    {  6607496772837067824u, 1343575221513417750u },
    { 17332926989895652603u, 1736530273035216783u },
    { 13037379183483547984u, 2244412773384604712u },
    {  1605989338741628675u, 1450417759929778918u },
    {  9630225068416591280u, 1874621017369538693u },
    {   665883850346957067u, 1211445438634777304u },
    { 14931890668723713708u, 1565756531257009982u }
  };

  const uint32_t POW5_OFFSETS[21] = {
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x40000000, 0x59695995,
    0x55545555, 0x56555515, 0x41150504, 0x40555410, 0x44555145, 0x44504540,
    0x45555550, 0x40004000, 0x96440440, 0x55565565, 0x54454045, 0x40154151,
    0x55559155, 0x51405555, 0x00000105
  };

  static constexpr uint32_t POW5_TABLE_SIZE = 26;
  const uint64_t DOUBLE_POW5_TABLE[POW5_TABLE_SIZE] = {
  1ull, 5ull, 25ull, 125ull, 625ull, 3125ull, 15625ull, 78125ull, 390625ull,
  1953125ull, 9765625ull, 48828125ull, 244140625ull, 1220703125ull, 6103515625ull,
  30517578125ull, 152587890625ull, 762939453125ull, 3814697265625ull,
  19073486328125ull, 95367431640625ull, 476837158203125ull,
  2384185791015625ull, 11920928955078125ull, 59604644775390625ull,
  298023223876953125ull //, 1490116119384765625ull
  };

  // Returns e == 0 ? 1 : [log_2(5^e)]; requires 0 <= e <= 3528.
  __device__ inline int32_t log2pow5(const int32_t e) {
    // This approximation works up to the point that the multiplication overflows at e = 3529.
    // If the multiplication were done in 64 bits, it would fail at 5^4004 which is just greater
    // than 2^9297.
    assert(e >= 0);
    assert(e <= 3528);
    return (int32_t) ((((uint32_t) e) * 1217359) >> 19);
  }

  // Returns e == 0 ? 1 : ceil(log_2(5^e)); requires 0 <= e <= 3528.
  __device__ inline int32_t pow5bits(const int32_t e) {
    // This approximation works up to the point that the multiplication overflows at e = 3529.
    // If the multiplication were done in 64 bits, it would fail at 5^4004 which is just greater
    // than 2^9297.
    assert(e >= 0);
    assert(e <= 3528);
    return (int32_t) (((((uint32_t) e) * 1217359) >> 19) + 1);
  }

  // Returns e == 0 ? 1 : ceil(log_2(5^e)); requires 0 <= e <= 3528.
  __device__ inline int32_t ceil_log2pow5(const int32_t e) {
    return log2pow5(e) + 1;
  }

  // Returns floor(log_10(2^e)); requires 0 <= e <= 1650.
  __device__ inline uint32_t log10Pow2(const int32_t e) {
    // The first value this approximation fails for is 2^1651 which is just greater than 10^297.
    assert(e >= 0);
    assert(e <= 1650);
    return (((uint32_t) e) * 78913) >> 18;
  }

  // Returns floor(log_10(5^e)); requires 0 <= e <= 2620.
  __device__ inline uint32_t log10Pow5(const int32_t e) {
    // The first value this approximation fails for is 5^2621 which is just greater than 10^1832.
    assert(e >= 0);
    assert(e <= 2620);
    return (((uint32_t) e) * 732923) >> 20;
  }

  __device__ inline uint32_t pow5factor_32(uint32_t value) {
    uint32_t count = 0;
    for (;;) {
      assert(value != 0);
      const uint32_t q = value / 5;
      const uint32_t r = value % 5;
      if (r != 0) {
        break;
      }
      value = q;
      ++count;
    }
    return count;
  }

  // Returns true if value is divisible by 5^p.
  __device__ inline bool multipleOfPowerOf5_32(const uint32_t value, const uint32_t p) {
    return pow5factor_32(value) >= p;
  }

  // Returns true if value is divisible by 2^p.
  __device__ inline bool multipleOfPowerOf2_32(const uint32_t value, const uint32_t p) {
    // __builtin_ctz doesn't appear to be faster here.
    return (value & ((1u << p) - 1)) == 0;
  }

  // It seems to be slightly faster to avoid uint128_t here, although the
  // generated code for uint128_t looks slightly nicer.
  __device__ inline uint32_t mulShift32(const uint32_t m, const uint64_t factor, const int32_t shift) {
    assert(shift > 32);

    // The casts here help MSVC to avoid calls to the __allmul library
    // function.
    const uint32_t factorLo = (uint32_t)(factor);
    const uint32_t factorHi = (uint32_t)(factor >> 32);
    const uint64_t bits0 = (uint64_t)m * factorLo;
    const uint64_t bits1 = (uint64_t)m * factorHi;

    const uint64_t sum = (bits0 >> 32) + bits1;
    const uint64_t shiftedSum = sum >> (shift - 32);
    assert(shiftedSum <= UINT32_MAX);
    return (uint32_t) shiftedSum;

  }

  __device__ inline int copy_special_str(char * const result, const bool sign, const bool exponent, const bool mantissa) {
    if (mantissa) {
      memcpy(result, "NaN", 3);
      return 3;
    }
    if (sign) {
      result[0] = '-';
    }
    if (exponent) {
      memcpy(result + sign, "Infinity", 8);
      return sign + 8;
    }
    memcpy(result + sign, "0.0", 3);
    return sign + 3;
  }

  __device__ inline int special_str_size(const bool sign, const bool exponent, const bool mantissa) {
    if (mantissa) {
      return 3;
    }
    if (exponent) {
      return sign + 8;
    }
    return sign + 3;
  }

  __device__ inline uint32_t float_to_bits(const float f) {
    uint32_t bits = 0;
    memcpy(&bits, &f, sizeof(float));
    return bits;
  }

  __device__ inline uint64_t double_to_bits(const double d) {
    uint64_t bits = 0;
    memcpy(&bits, &d, sizeof(double));
    return bits;
  }

  __device__ inline uint64_t umul128(const uint64_t a, const uint64_t b, uint64_t* const productHi) {
    // The casts here help MSVC to avoid calls to the __allmul library function.
    const uint32_t aLo = (uint32_t)a;
    const uint32_t aHi = (uint32_t)(a >> 32);
    const uint32_t bLo = (uint32_t)b;
    const uint32_t bHi = (uint32_t)(b >> 32);

    const uint64_t b00 = (uint64_t)aLo * bLo;
    const uint64_t b01 = (uint64_t)aLo * bHi;
    const uint64_t b10 = (uint64_t)aHi * bLo;
    const uint64_t b11 = (uint64_t)aHi * bHi;

    const uint32_t b00Lo = (uint32_t)b00;
    const uint32_t b00Hi = (uint32_t)(b00 >> 32);

    const uint64_t mid1 = b10 + b00Hi;
    const uint32_t mid1Lo = (uint32_t)(mid1);
    const uint32_t mid1Hi = (uint32_t)(mid1 >> 32);

    const uint64_t mid2 = b01 + mid1Lo;
    const uint32_t mid2Lo = (uint32_t)(mid2);
    const uint32_t mid2Hi = (uint32_t)(mid2 >> 32);

    const uint64_t pHi = b11 + mid1Hi + mid2Hi;
    const uint64_t pLo = ((uint64_t)mid2Lo << 32) | b00Lo;

    *productHi = pHi;
    return pLo;
  }

  __device__ inline uint64_t shiftright128(const uint64_t lo, const uint64_t hi, const uint32_t dist) {
    // We don't need to handle the case dist >= 64 here (see above).
    assert(dist < 64);
    assert(dist > 0);
    return (hi << (64 - dist)) | (lo >> dist);
  }

  __device__ inline uint64_t div5(const uint64_t x) {
    return x / 5;
  }

  __device__ inline uint64_t div10(const uint64_t x) {
    return x / 10;
  }

  __device__ inline uint64_t div100(const uint64_t x) {
    return x / 100;
  }

  __device__ inline uint64_t div1e8(const uint64_t x) {
    return x / 100000000;
  }

  __device__ inline uint64_t div1e9(const uint64_t x) {
    return x / 1000000000;
  }

  __device__ inline uint32_t mod1e9(const uint64_t x) {
    return (uint32_t) (x - 1000000000 * div1e9(x));
  }

  __device__ inline uint32_t pow5Factor(uint64_t value) {
    const uint64_t m_inv_5 = 14757395258967641293u; // 5 * m_inv_5 = 1 (mod 2^64)
    const uint64_t n_div_5 = 3689348814741910323u;  // #{ n | n = 0 (mod 2^64) } = 2^64 / 5
    uint32_t count = 0;
    for (;;) {
      assert(value != 0);
      value *= m_inv_5;
      if (value > n_div_5)
        break;
      ++count;
    }
    return count;
  }

  // Returns true if value is divisible by 5^p.
  __device__ inline bool multipleOfPowerOf5(const uint64_t value, const uint32_t p) {
    // I tried a case distinction on p, but there was no performance difference.
    return pow5Factor(value) >= p;
  }

  // Returns true if value is divisible by 2^p.
  __device__ inline bool multipleOfPowerOf2(const uint64_t value, const uint32_t p) {
    assert(value != 0);
    assert(p < 64);
    // __builtin_ctzll doesn't appear to be faster here.
    return (value & ((1ull << p) - 1)) == 0;
  }

  __device__ inline uint64_t mulShift64(const uint64_t m, const uint64_t* const mul, const int32_t j) {
    // m is maximum 55 bits
    uint64_t high1;                                   // 128
    const uint64_t low1 = umul128(m, mul[1], &high1); // 64
    uint64_t high0;                                   // 64
    umul128(m, mul[0], &high0);                       // 0
    const uint64_t sum = high0 + low1;
    if (sum < high0) {
      ++high1; // overflow into high1
    }
    return shiftright128(sum, high1, j - 64);
  }

  __device__ inline uint64_t mulShiftAll64(const uint64_t m, const uint64_t* const mul, const int32_t j,
    uint64_t* const vp, uint64_t* const vm, const uint32_t mmShift) {
    *vp = mulShift64(4 * m + 2, mul, j);
    *vm = mulShift64(4 * m - 1 - mmShift, mul, j);
    return mulShift64(4 * m, mul, j);
  }

  // Computes 5^i in the form required by Ryu, and stores it in the given pointer.
  __device__ inline void double_computePow5(const uint32_t i, uint64_t* const result) {
    const uint32_t base = i / POW5_TABLE_SIZE;
    const uint32_t base2 = base * POW5_TABLE_SIZE;
    const uint32_t offset = i - base2;
    const uint64_t* const mul = DOUBLE_POW5_SPLIT2[base];
    if (offset == 0) {
      result[0] = mul[0];
      result[1] = mul[1];
      return;
    }
    const uint64_t m = DOUBLE_POW5_TABLE[offset];
    uint64_t high1;
    const uint64_t low1 = umul128(m, mul[1], &high1);
    uint64_t high0;
    const uint64_t low0 = umul128(m, mul[0], &high0);
    const uint64_t sum = high0 + low1;
    if (sum < high0) {
      ++high1; // overflow into high1
    }
    // high1 | sum | low0
    const uint32_t delta = pow5bits(i) - pow5bits(base2);
    result[0] = shiftright128(low0, sum, delta) + ((POW5_OFFSETS[i / 16] >> ((i % 16) << 1)) & 3);
    result[1] = shiftright128(sum, high1, delta);
  }

  // Computes 5^-i in the form required by Ryu, and stores it in the given pointer.
  __device__ inline void double_computeInvPow5(const uint32_t i, uint64_t* const result) {
    const uint32_t base = (i + POW5_TABLE_SIZE - 1) / POW5_TABLE_SIZE;
    const uint32_t base2 = base * POW5_TABLE_SIZE;
    const uint32_t offset = base2 - i;
    const uint64_t* const mul = DOUBLE_POW5_INV_SPLIT2[base]; // 1/5^base2
    if (offset == 0) {
      result[0] = mul[0];
      result[1] = mul[1];
      return;
    }
    const uint64_t m = DOUBLE_POW5_TABLE[offset];
    uint64_t high1;
    const uint64_t low1 = umul128(m, mul[1], &high1);
    uint64_t high0;
    const uint64_t low0 = umul128(m, mul[0] - 1, &high0);
    const uint64_t sum = high0 + low1;
    if (sum < high0) {
      ++high1; // overflow into high1
    }
    // high1 | sum | low0
    const uint32_t delta = pow5bits(base2) - pow5bits(i);
    result[0] = shiftright128(low0, sum, delta) + 1 + ((POW5_INV_OFFSETS[i / 16] >> ((i % 16) << 1)) & 3);
    result[1] = shiftright128(sum, high1, delta);
  }

  __device__ inline uint32_t mulPow5InvDivPow2(const uint32_t m, const uint32_t q, const int32_t j) {
    // The inverse multipliers are defined as [2^x / 5^y] + 1; the upper 64 bits from the double lookup
    // table are the correct bits for [2^x / 5^y], so we have to add 1 here. Note that we rely on the
    // fact that the added 1 that's already stored in the table never overflows into the upper 64 bits.
    uint64_t pow5[2];
    double_computeInvPow5(q, pow5);
    return mulShift32(m, pow5[1] + 1, j);
  }

  __device__ inline uint32_t mulPow5divPow2(const uint32_t m, const uint32_t i, const int32_t j) {
    uint64_t pow5[2];
    double_computePow5(i, pow5);
    return mulShift32(m, pow5[1], j);
  }

  __device__ inline uint32_t decimalLength17(const uint64_t v) {
    // This is slightly faster than a loop.
    // The average output length is 16.38 digits, so we check high-to-low.
    // Function precondition: v is not an 18, 19, or 20-digit number.
    // (17 digits are sufficient for round-tripping.)
    assert(v < 100000000000000000L);
    if (v >= 10000000000000000L) { return 17; }
    if (v >= 1000000000000000L) { return 16; }
    if (v >= 100000000000000L) { return 15; }
    if (v >= 10000000000000L) { return 14; }
    if (v >= 1000000000000L) { return 13; }
    if (v >= 100000000000L) { return 12; }
    if (v >= 10000000000L) { return 11; }
    if (v >= 1000000000L) { return 10; }
    if (v >= 100000000L) { return 9; }
    if (v >= 10000000L) { return 8; }
    if (v >= 1000000L) { return 7; }
    if (v >= 100000L) { return 6; }
    if (v >= 10000L) { return 5; }
    if (v >= 1000L) { return 4; }
    if (v >= 100L) { return 3; }
    if (v >= 10L) { return 2; }
    return 1;
  }

  __device__ inline floating_decimal_64 d2d(const uint64_t ieeeMantissa, const uint32_t ieeeExponent) {
    int32_t e2;
    uint64_t m2;
    if (ieeeExponent == 0) {
      // We subtract 2 so that the bounds computation has 2 additional bits.
      e2 = 1 - DOUBLE_BIAS - DOUBLE_MANTISSA_BITS - 2;
      m2 = ieeeMantissa;
    } else {
      e2 = (int32_t) ieeeExponent - DOUBLE_BIAS - DOUBLE_MANTISSA_BITS - 2;
      m2 = (1ull << DOUBLE_MANTISSA_BITS) | ieeeMantissa;
    }
    const bool even = (m2 & 1) == 0;
    const bool acceptBounds = even;

    // Step 2: Determine the interval of valid decimal representations.
    const uint64_t mv = 4 * m2;
    // Implicit bool -> int conversion. True is 1, false is 0.
    const uint32_t mmShift = ieeeMantissa != 0 || ieeeExponent <= 1;
    // We would compute mp and mm like this:
    // uint64_t mp = 4 * m2 + 2;
    // uint64_t mm = mv - 1 - mmShift;

    // Step 3: Convert to a decimal power base using 128-bit arithmetic.
    uint64_t vr, vp, vm;
    int32_t e10;
    bool vmIsTrailingZeros = false;
    bool vrIsTrailingZeros = false;
    if (e2 >= 0) {
      // I tried special-casing q == 0, but there was no effect on performance.
      // This expression is slightly faster than max(0, log10Pow2(e2) - 1).
      const uint32_t q = log10Pow2(e2) - (e2 > 3);
      e10 = (int32_t) q;
      const int32_t k = DOUBLE_POW5_INV_BITCOUNT + pow5bits((int32_t) q) - 1;
      const int32_t i = -e2 + (int32_t) q + k;
      uint64_t pow5[2];
      double_computeInvPow5(q, pow5);
      vr = mulShiftAll64(m2, pow5, i, &vp, &vm, mmShift);

      if (q <= 21) {
        // This should use q <= 22, but I think 21 is also safe. Smaller values
        // may still be safe, but it's more difficult to reason about them.
        // Only one of mp, mv, and mm can be a multiple of 5, if any.
        const uint32_t mvMod5 = ((uint32_t) mv) - 5 * ((uint32_t) div5(mv));
        if (mvMod5 == 0) {
          vrIsTrailingZeros = multipleOfPowerOf5(mv, q);
        } else if (acceptBounds) {
          // Same as min(e2 + (~mm & 1), pow5Factor(mm)) >= q
          // <=> e2 + (~mm & 1) >= q && pow5Factor(mm) >= q
          // <=> true && pow5Factor(mm) >= q, since e2 >= q.
          vmIsTrailingZeros = multipleOfPowerOf5(mv - 1 - mmShift, q);
        } else {
          // Same as min(e2 + 1, pow5Factor(mp)) >= q.
          vp -= multipleOfPowerOf5(mv + 2, q);
        }
      }
    } else {
      // This expression is slightly faster than max(0, log10Pow5(-e2) - 1).
      const uint32_t q = log10Pow5(-e2) - (-e2 > 1);
      e10 = (int32_t) q + e2;
      const int32_t i = -e2 - (int32_t) q;
      const int32_t k = pow5bits(i) - DOUBLE_POW5_BITCOUNT;
      const int32_t j = (int32_t) q - k;

      uint64_t pow5[2];
      double_computePow5(i, pow5);
      vr = mulShiftAll64(m2, pow5, j, &vp, &vm, mmShift);

      if (q <= 1) {
        // {vr,vp,vm} is trailing zeros if {mv,mp,mm} has at least q trailing 0 bits.
        // mv = 4 * m2, so it always has at least two trailing 0 bits.
        vrIsTrailingZeros = true;
        if (acceptBounds) {
          // mm = mv - 1 - mmShift, so it has 1 trailing 0 bit iff mmShift == 1.
          vmIsTrailingZeros = mmShift == 1;
        } else {
          // mp = mv + 2, so it always has at least one trailing 0 bit.
          --vp;
        }
      } else if (q < 63) { // TODO(ulfjack): Use a tighter bound here.
        // We want to know if the full product has at least q trailing zeros.
        // We need to compute min(p2(mv), p5(mv) - e2) >= q
        // <=> p2(mv) >= q && p5(mv) - e2 >= q
        // <=> p2(mv) >= q (because -e2 >= q)
        vrIsTrailingZeros = multipleOfPowerOf2(mv, q);
      }
    }

    // Step 4: Find the shortest decimal representation in the interval of valid representations.
    int32_t removed = 0;
    uint8_t lastRemovedDigit = 0;
    uint64_t output;
    // On average, we remove ~2 digits.
    if (vmIsTrailingZeros || vrIsTrailingZeros) {
      // General case, which happens rarely (~0.7%).
      for (;;) {
        const uint64_t vpDiv10 = div10(vp);
        const uint64_t vmDiv10 = div10(vm);
        if (vpDiv10 <= vmDiv10) {
          break;
        }
        const uint32_t vmMod10 = ((uint32_t) vm) - 10 * ((uint32_t) vmDiv10);
        const uint64_t vrDiv10 = div10(vr);
        const uint32_t vrMod10 = ((uint32_t) vr) - 10 * ((uint32_t) vrDiv10);
        vmIsTrailingZeros &= vmMod10 == 0;
        vrIsTrailingZeros &= lastRemovedDigit == 0;
        lastRemovedDigit = (uint8_t) vrMod10;
        vr = vrDiv10;
        vp = vpDiv10;
        vm = vmDiv10;
        ++removed;
      }

      if (vmIsTrailingZeros) {
        for (;;) {
          const uint64_t vmDiv10 = div10(vm);
          const uint32_t vmMod10 = ((uint32_t) vm) - 10 * ((uint32_t) vmDiv10);
          if (vmMod10 != 0) {
            break;
          }
          const uint64_t vpDiv10 = div10(vp);
          const uint64_t vrDiv10 = div10(vr);
          const uint32_t vrMod10 = ((uint32_t) vr) - 10 * ((uint32_t) vrDiv10);
          vrIsTrailingZeros &= lastRemovedDigit == 0;
          lastRemovedDigit = (uint8_t) vrMod10;
          vr = vrDiv10;
          vp = vpDiv10;
          vm = vmDiv10;
          ++removed;
        }
      }

      if (vrIsTrailingZeros && lastRemovedDigit == 5 && vr % 2 == 0) {
        // Round even if the exact number is .....50..0.
        lastRemovedDigit = 4;
      }
      // We need to take vr + 1 if vr is outside bounds or we need to round up.
      output = vr + ((vr == vm && (!acceptBounds || !vmIsTrailingZeros)) || lastRemovedDigit >= 5);
    } else {
      // Specialized for the common case (~99.3%). Percentages below are relative to this.
      bool roundUp = false;
      const uint64_t vpDiv100 = div100(vp);
      const uint64_t vmDiv100 = div100(vm);
      if (vpDiv100 > vmDiv100) { // Optimization: remove two digits at a time (~86.2%).
        const uint64_t vrDiv100 = div100(vr);
        const uint32_t vrMod100 = ((uint32_t) vr) - 100 * ((uint32_t) vrDiv100);
        roundUp = vrMod100 >= 50;
        vr = vrDiv100;
        vp = vpDiv100;
        vm = vmDiv100;
        removed += 2;
      }
      // Loop iterations below (approximately), without optimization above:
      // 0: 0.03%, 1: 13.8%, 2: 70.6%, 3: 14.0%, 4: 1.40%, 5: 0.14%, 6+: 0.02%
      // Loop iterations below (approximately), with optimization above:
      // 0: 70.6%, 1: 27.8%, 2: 1.40%, 3: 0.14%, 4+: 0.02%
      for (;;) {
        const uint64_t vpDiv10 = div10(vp);
        const uint64_t vmDiv10 = div10(vm);
        if (vpDiv10 <= vmDiv10) {
          break;
        }
        const uint64_t vrDiv10 = div10(vr);
        const uint32_t vrMod10 = ((uint32_t) vr) - 10 * ((uint32_t) vrDiv10);
        roundUp = vrMod10 >= 5;
        vr = vrDiv10;
        vp = vpDiv10;
        vm = vmDiv10;
        ++removed;
      }

      // We need to take vr + 1 if vr is outside bounds or we need to round up.
      output = vr + (vr == vm || roundUp);
    }
    const int32_t exp = e10 + removed;

    floating_decimal_64 fd;
    fd.exponent = exp;
    fd.mantissa = output;
    return fd;
  }

  __device__ inline floating_decimal_32 f2d(const uint32_t ieeeMantissa, const uint32_t ieeeExponent) {
    int32_t e2;
    uint32_t m2;
    if (ieeeExponent == 0) {
      // We subtract 2 so that the bounds computation has 2 additional bits.
      e2 = 1 - FLOAT_BIAS - FLOAT_MANTISSA_BITS - 2;
      m2 = ieeeMantissa;
    } else {
      e2 = (int32_t) ieeeExponent - FLOAT_BIAS - FLOAT_MANTISSA_BITS - 2;
      m2 = (1u << FLOAT_MANTISSA_BITS) | ieeeMantissa;
    }
    const bool even = (m2 & 1) == 0;
    const bool acceptBounds = even;

    // Step 2: Determine the interval of valid decimal representations.
    const uint32_t mv = 4 * m2;
    const uint32_t mp = 4 * m2 + 2;
    // Implicit bool -> int conversion. True is 1, false is 0.
    const uint32_t mmShift = ieeeMantissa != 0 || ieeeExponent <= 1;
    const uint32_t mm = 4 * m2 - 1 - mmShift;

    // Step 3: Convert to a decimal power base using 64-bit arithmetic.
    uint32_t vr, vp, vm;
    int32_t e10;
    bool vmIsTrailingZeros = false;
    bool vrIsTrailingZeros = false;
    uint8_t lastRemovedDigit = 0;
    if (e2 >= 0) {
      const uint32_t q = log10Pow2(e2);
      e10 = (int32_t) q;
      const int32_t k = FLOAT_POW5_INV_BITCOUNT + pow5bits((int32_t) q) - 1;
      const int32_t i = -e2 + (int32_t) q + k;
      vr = mulPow5InvDivPow2(mv, q, i);
      vp = mulPow5InvDivPow2(mp, q, i);
      vm = mulPow5InvDivPow2(mm, q, i);
      if (q != 0 && (vp - 1) / 10 <= vm / 10) {
        // We need to know one removed digit even if we are not going to loop below. We could use
        // q = X - 1 above, except that would require 33 bits for the result, and we've found that
        // 32-bit arithmetic is faster even on 64-bit machines.
        const int32_t l = FLOAT_POW5_INV_BITCOUNT + pow5bits((int32_t) (q - 1)) - 1;
        lastRemovedDigit = (uint8_t) (mulPow5InvDivPow2(mv, q - 1, -e2 + (int32_t) q - 1 + l) % 10);
      }
      if (q <= 9) {
        // The largest power of 5 that fits in 24 bits is 5^10, but q <= 9 seems to be safe as well.
        // Only one of mp, mv, and mm can be a multiple of 5, if any.
        if (mv % 5 == 0) {
          vrIsTrailingZeros = multipleOfPowerOf5_32(mv, q);
        } else if (acceptBounds) {
          vmIsTrailingZeros = multipleOfPowerOf5_32(mm, q);
        } else {
          vp -= multipleOfPowerOf5_32(mp, q);
        }
      }
    } else {
      const uint32_t q = log10Pow5(-e2);
      e10 = (int32_t) q + e2;
      const int32_t i = -e2 - (int32_t) q;
      const int32_t k = pow5bits(i) - FLOAT_POW5_BITCOUNT;
      int32_t j = (int32_t) q - k;
      vr = mulPow5divPow2(mv, (uint32_t) i, j);
      vp = mulPow5divPow2(mp, (uint32_t) i, j);
      vm = mulPow5divPow2(mm, (uint32_t) i, j);
      if (q != 0 && (vp - 1) / 10 <= vm / 10) {
        j = (int32_t) q - 1 - (pow5bits(i + 1) - FLOAT_POW5_BITCOUNT);
        lastRemovedDigit = (uint8_t) (mulPow5divPow2(mv, (uint32_t) (i + 1), j) % 10);
      }
      if (q <= 1) {
        // {vr,vp,vm} is trailing zeros if {mv,mp,mm} has at least q trailing 0 bits.
        // mv = 4 * m2, so it always has at least two trailing 0 bits.
        vrIsTrailingZeros = true;
        if (acceptBounds) {
          // mm = mv - 1 - mmShift, so it has 1 trailing 0 bit iff mmShift == 1.
          vmIsTrailingZeros = mmShift == 1;
        } else {
          // mp = mv + 2, so it always has at least one trailing 0 bit.
          --vp;
        }
      } else if (q < 31) { // TODO(ulfjack): Use a tighter bound here.
        vrIsTrailingZeros = multipleOfPowerOf2_32(mv, q - 1);
      }
    }

    // Step 4: Find the shortest decimal representation in the interval of valid representations.
    int32_t removed = 0;
    uint32_t output;
    if (vmIsTrailingZeros || vrIsTrailingZeros) {
      // General case, which happens rarely (~4.0%).
      while (vp / 10 > vm / 10) {
        vmIsTrailingZeros &= vm % 10 == 0;
        vrIsTrailingZeros &= lastRemovedDigit == 0;
        lastRemovedDigit = (uint8_t) (vr % 10);
        vr /= 10;
        vp /= 10;
        vm /= 10;
        ++removed;
      }
      if (vmIsTrailingZeros) {
        while (vm % 10 == 0) {
          vrIsTrailingZeros &= lastRemovedDigit == 0;
          lastRemovedDigit = (uint8_t) (vr % 10);
          vr /= 10;
          vp /= 10;
          vm /= 10;
          ++removed;
        }
      }
      if (vrIsTrailingZeros && lastRemovedDigit == 5 && vr % 2 == 0) {
        // Round even if the exact number is .....50..0.
        lastRemovedDigit = 4;
      }
      // We need to take vr + 1 if vr is outside bounds or we need to round up.
      output = vr + ((vr == vm && (!acceptBounds || !vmIsTrailingZeros)) || lastRemovedDigit >= 5);
    } else {
      // Specialized for the common case (~96.0%). Percentages below are relative to this.
      // Loop iterations below (approximately):
      // 0: 13.6%, 1: 70.7%, 2: 14.1%, 3: 1.39%, 4: 0.14%, 5+: 0.01%
      while (vp / 10 > vm / 10) {
        lastRemovedDigit = (uint8_t) (vr % 10);
        vr /= 10;
        vp /= 10;
        vm /= 10;
        ++removed;
      }
      // We need to take vr + 1 if vr is outside bounds or we need to round up.
      output = vr + (vr == vm || lastRemovedDigit >= 5);
    }
    const int32_t exp = e10 + removed;

    floating_decimal_32 fd;
    fd.exponent = exp;
    fd.mantissa = output;
    return fd;
  }

  __device__ inline int to_chars(const floating_decimal_64 v, const bool sign, char* const result) {
    // Step 5: Print the decimal representation.
    int index = 0;
    if (sign) {
      result[index++] = '-';
    }

    uint64_t output = v.mantissa;
    const uint32_t olength = decimalLength17(output);
    int32_t exp = v.exponent + (int32_t) olength - 1;
    bool scientificNotation = (exp < -3) || (exp >= 7);
    
    // Values in the interval [1E-3, 1E7) are special.
    if (scientificNotation) {
      // Print in the format x.xxxxxE-yy.
      for (uint32_t i = 0; i < olength - 1; ++i) {
        const uint32_t c = output % 10; output /= 10;
        result[index + olength - i] = (char) ('0' + c);
      }
      result[index] = '0' + output % 10;
      result[index + 1] = '.';
      index += olength + 1;
      if (olength == 1) {
        result[index++] = '0';
      }
      // Print 'E', the exponent sign, and the exponent, which has at most three digits.
      result[index++] = 'E';
      if (exp < 0) {
        result[index++] = '-';
        exp = -exp;
      }
      if (exp >= 100) {
          result[index++] = (char) ('0' + exp / 100);
          exp %= 100;
          result[index++] = (char) ('0' + exp / 10);
        } else if (exp >= 10) {
          result[index++] = (char) ('0' + exp / 10);
        }
        result[index++] = (char) ('0' + exp % 10);
    } else {
      // Otherwise follow the Java spec for values in the interval [1E-3, 1E7).
      if (exp < 0) {
        // Decimal dot is before any of the digits.
        result[index++] = '0';
        result[index++] = '.';
        for (int i = -1; i > exp; i--) {
          result[index++] = '0';
        }
        int current = index;
        for (int i = 0; i < olength; i++) {
          result[current + olength - i - 1] = (char) ('0' + output % 10);
          output /= 10;
          index++;
        }
      } else if (exp + 1 >= olength) {
        // Decimal dot is after any of the digits.
        for (int i = 0; i < olength; i++) {
          result[index + olength - i - 1] = (char) ('0' + output % 10);
          output /= 10;
        }
        index += olength;
        for (int i = olength; i < exp + 1; i++) {
          result[index++] = '0';
        }
        result[index++] = '.';
        result[index++] = '0';
      } else {
        // Decimal dot is somewhere between the digits.
        int current = index + 1;
        for (int i = 0; i < olength; i++) {
          if (olength - i - 1 == exp) {
            result[current + olength - i - 1] = '.';
            current--;
          }
          result[current + olength - i - 1] = (char) ('0' + output % 10);
          output /= 10;
        }
        index += olength + 1;
      }
    }
    return index;
  }

  __device__ inline int d2s_size(const floating_decimal_64 v, const bool sign) {
    int index = 0;
    if (sign) {
      index++;
    }

    uint64_t output = v.mantissa;
    const uint32_t olength = decimalLength17(output);
    int32_t exp = v.exponent + (int32_t) olength - 1;
    bool scientificNotation = (exp < -3) || (exp >= 7);
    
    if (scientificNotation) {
      index += olength + 1;
      if (olength == 1) {
        index++;
      }
      // 'E'
      index++;
      if (exp < 0) {
        exp = -exp;
        index++;
      }
      if (exp >= 100) {
        index += 3;
      } else if (exp >= 10) {
        index += 2;
      } else {
        index++;
      }
    } else {
      // Otherwise follow the Java spec for values in the interval [1E-3, 1E7).
      if (exp < 0) {
        index += 1 - exp + olength;
      } else if (exp + 1 >= olength) {
        index += exp + 3;
      } else {
        index += olength + 1;
      }
    }
    return index;
  }

  __device__ inline int to_chars(const floating_decimal_32 v, const bool sign, char* const result) {
    // Step 5: Print the decimal representation.
    int index = 0;
    if (sign) {
      result[index++] = '-';
    }

    uint32_t output = v.mantissa;
    const uint32_t olength = decimalLength9(output);
    int32_t exp = v.exponent + olength - 1;
    bool scientificNotation = (exp < -3) || (exp >= 7);

    if (scientificNotation) {
      // Print in the format x.xxxxxE-yy.
      for (int i = 0; i < olength - 1; i++) {
        int c = output % 10; output /= 10;
        result[index + olength - i] = (char) ('0' + c);
      }
      result[index] = (char) ('0' + output % 10);
      result[index + 1] = '.';
      index += olength + 1;
      if (olength == 1) {
        result[index++] = '0';
      }

      // Print 'E', the exponent sign, and the exponent, which has at most two digits.
      result[index++] = 'E';
      if (exp < 0) {
        result[index++] = '-';
        exp = -exp;
      }
      if (exp >= 10) {
        result[index++] = (char) ('0' + exp / 10);
      }
      result[index++] = (char) ('0' + exp % 10);
    } else {
      // Otherwise follow the Java spec for values in the interval [1E-3, 1E7).
      if (exp < 0) {
        // Decimal dot is before any of the digits.
        result[index++] = '0';
        result[index++] = '.';
        for (int i = -1; i > exp; i--) {
          result[index++] = '0';
        }
        int current = index;
        for (int i = 0; i < olength; i++) {
          result[current + olength - i - 1] = (char) ('0' + output % 10);
          output /= 10;
          index++;
        }
      } else if (exp + 1 >= olength) {
        // Decimal dot is after any of the digits.
        for (int i = 0; i < olength; i++) {
          result[index + olength - i - 1] = (char) ('0' + output % 10);
          output /= 10;
        }
        index += olength;
        for (int i = olength; i < exp + 1; i++) {
          result[index++] = '0';
        }
        result[index++] = '.';
        result[index++] = '0';
      } else {
        // Decimal dot is somewhere between the digits.
        int current = index + 1;
        for (int i = 0; i < olength; i++) {
          if (olength - i - 1 == exp) {
            result[current + olength - i - 1] = '.';
            current--;
          }
          result[current + olength - i - 1] = (char) ('0' + output % 10);
          output /= 10;
        }
        index += olength + 1;
      }
    }
    return index;
  }

  __device__ inline int f2s_size(const floating_decimal_32 v, const bool sign) {
    // Step 5: Print the decimal representation.
    int index = 0;
    if (sign) {
      index++;
    }

    uint32_t output = v.mantissa;
    const uint32_t olength = decimalLength9(output);
    int32_t exp = v.exponent + olength - 1;
    bool scientificNotation = (exp < -3) || (exp >= 7);

    if (scientificNotation) {
      index += olength + 1;
      if (olength == 1) {
        index++;
      }
      // 'E'
      index++;
      if (exp < 0) {
        index++;
        exp = -exp;
      }
      if (exp >= 10) {
        index++;
      }
      index++;
    } else {
      // Otherwise follow the Java spec for values in the interval [1E-3, 1E7).
      if (exp < 0) {
        // Decimal dot is before any of the digits.
        index += 1 - exp + olength;
      } else if (exp + 1 >= olength) {
        // Decimal dot is after any of the digits.
        index += exp + 3;
      } else {
        // Decimal dot is somewhere between the digits.
        index += olength + 1;
      }
    }
    return index;
  }

  __device__ inline bool d2d_small_int(const uint64_t ieeeMantissa, const uint32_t ieeeExponent,
    floating_decimal_64* const v) {
    const uint64_t m2 = (1ull << DOUBLE_MANTISSA_BITS) | ieeeMantissa;
    const int32_t e2 = (int32_t) ieeeExponent - DOUBLE_BIAS - DOUBLE_MANTISSA_BITS;

    if (e2 > 0) {
      // f = m2 * 2^e2 >= 2^53 is an integer.
      // Ignore this case for now.
      return false;
    }

    if (e2 < -52) {
      // f < 1.
      return false;
    }

    // Since 2^52 <= m2 < 2^53 and 0 <= -e2 <= 52: 1 <= f = m2 / 2^-e2 < 2^53.
    // Test if the lower -e2 bits of the significand are 0, i.e. whether the fraction is 0.
    const uint64_t mask = (1ull << -e2) - 1;
    const uint64_t fraction = m2 & mask;
    if (fraction != 0) {
      return false;
    }

    // f is an integer in the range [1, 2^53).
    // Note: mantissa might contain trailing (decimal) 0's.
    // Note: since 2^53 < 10^16, there is no need to adjust decimalLength17().
    v->mantissa = m2 >> -e2;
    v->exponent = 0;
    return true;
  }

  __device__ floating_decimal_64 d2d(double f, bool& ieeeSign, bool& special) {
    // Step 1: Decode the floating-point number, and unify normalized and subnormal cases.
    const uint64_t bits = double_to_bits(f);

    // Decode bits into sign, mantissa, and exponent.
    ieeeSign = ((bits >> (DOUBLE_MANTISSA_BITS + DOUBLE_EXPONENT_BITS)) & 1) != 0;
    const uint64_t ieeeMantissa = bits & ((1ull << DOUBLE_MANTISSA_BITS) - 1);
    const uint32_t ieeeExponent = (uint32_t) ((bits >> DOUBLE_MANTISSA_BITS) & ((1u << DOUBLE_EXPONENT_BITS) - 1));
    // Case distinction; exit early for the easy cases.
    if (ieeeExponent == ((1u << DOUBLE_EXPONENT_BITS) - 1u) || (ieeeExponent == 0 && ieeeMantissa == 0)) {
      special = true;
      return floating_decimal_64{ieeeMantissa, (int32_t)ieeeExponent};
    }
    special = false;
    floating_decimal_64 v;
    const bool isSmallInt = d2d_small_int(ieeeMantissa, ieeeExponent, &v);
    if (isSmallInt) {
      // For small integers in the range [1, 2^53), v.mantissa might contain trailing (decimal) zeros.
      // For scientific notation we need to move these zeros into the exponent.
      // (This is not needed for fixed-point notation, so it might be beneficial to trim
      // trailing zeros in to_chars only if needed - once fixed-point notation output is implemented.)
      for (;;) {
        const uint64_t q = div10(v.mantissa);
        const uint32_t r = ((uint32_t) v.mantissa) - 10 * ((uint32_t) q);
        if (r != 0) {
          break;
        }
        v.mantissa = q;
        ++v.exponent;
      }
    } else {
      v = d2d(ieeeMantissa, ieeeExponent);
    }
    return v;
  }

  __device__ int d2s_buffered_n(double f, char* result) {
    bool sign = false, special = false;
    floating_decimal_64 v = d2d(f, sign, special);
    if (special) {
      return copy_special_str(result, sign, v.exponent, v.mantissa);
    }
    return to_chars(v, sign, result);
  }

  __device__ int compute_d2s_size(double value) {
    bool sign = false, special = false;
    floating_decimal_64 v = d2d(value, sign, special);
    if (special) {
      return special_str_size(sign, v.exponent, v.mantissa);
    }
    return d2s_size(v, sign);
  }

  __device__ floating_decimal_32 f2d(float f, bool& ieeeSign, bool& special) {
    // Step 1: Decode the floating-point number, and unify normalized and subnormal cases.
    const uint32_t bits = float_to_bits(f);

    // Decode bits into sign, mantissa, and exponent.
    ieeeSign = ((bits >> (FLOAT_MANTISSA_BITS + FLOAT_EXPONENT_BITS)) & 1) != 0;
    const uint32_t ieeeMantissa = bits & ((1u << FLOAT_MANTISSA_BITS) - 1);
    const uint32_t ieeeExponent = (bits >> FLOAT_MANTISSA_BITS) & ((1u << FLOAT_EXPONENT_BITS) - 1);

    // Case distinction; exit early for the easy cases.
    if (ieeeExponent == ((1u << FLOAT_EXPONENT_BITS) - 1u) || (ieeeExponent == 0 && ieeeMantissa == 0)) {
      special = true;
      return floating_decimal_32{ieeeMantissa, (int32_t)ieeeExponent};
    }
    special = false;
    return f2d(ieeeMantissa, ieeeExponent);
  }

  __device__ int f2s_buffered_n(float f, char* result) {
    bool sign = false, special = false;
    floating_decimal_32 v = f2d(f, sign, special);
    if (special) {
      return copy_special_str(result, sign, v.exponent, v.mantissa);
    }
    return to_chars(v, sign, result);
  }

  __device__ int compute_f2s_size(float value) {
    bool sign = false, special = false;
    floating_decimal_32 v = f2d(value, sign, special);
    if (special) {
      return special_str_size(sign, v.exponent, v.mantissa);
    }
    return f2s_size(v, sign);
  }

  __device__ int compute_ftos_size(double value, bool is_float) {
    if (is_float) {
        return compute_f2s_size(value);
    } else {
        return compute_d2s_size(value);
    }
  }

  __device__ int float_to_string(double value, char* output, bool is_float) {
      if (is_float) {
          return f2s_buffered_n(value, output);
      } else {
          return d2s_buffered_n(value, output);
      }
  }
};

}
}
}
