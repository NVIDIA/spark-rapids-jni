/*
 * Copyright 2018 Ulf Adams
 * Copyright (c) 2023, NVIDIA CORPORATION.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#pragma once

#include <cuda/std/cassert>
#include <cuda/std/climits>
#include <cuda/std/cstdint>
#include <cuda/std/limits>
#include <cuda/std/type_traits>

namespace spark_rapids_jni::ftos_converter {

namespace {

// d2s.c from ryu
// A floating decimal representing m * 10^e.
typedef struct floating_decimal_64 {
  uint64_t mantissa;
  // Decimal exponent's range is -324 to 308
  // inclusive, and can fit in a short if needed.
  int32_t exponent;
} floating_decimal_64;

// f2s.c from ryu
// A floating decimal representing m * 10^e.
typedef struct floating_decimal_32 {
  uint32_t mantissa;
  // Decimal exponent's range is -45 to 38
  // inclusive, and can fit in a short if needed.
  int32_t exponent;
} floating_decimal_32;

//===== constants from ryu =====

// These tables are generated by PrintDoubleLookupTable.
constexpr unsigned int DOUBLE_POW5_INV_BITCOUNT = 125;
constexpr unsigned int DOUBLE_POW5_BITCOUNT     = 125;
constexpr unsigned int FLOAT_POW5_INV_BITCOUNT  = (DOUBLE_POW5_INV_BITCOUNT - 64);
constexpr unsigned int FLOAT_POW5_BITCOUNT      = (DOUBLE_POW5_BITCOUNT - 64);
constexpr unsigned int DOUBLE_MANTISSA_BITS     = 52;
constexpr unsigned int DOUBLE_EXPONENT_BITS     = 11;
constexpr unsigned int DOUBLE_BIAS              = 1023;
constexpr unsigned int FLOAT_MANTISSA_BITS      = 23;
constexpr unsigned int FLOAT_EXPONENT_BITS      = 8;
constexpr unsigned int FLOAT_BIAS               = 127;

__constant__ uint64_t const DOUBLE_POW5_INV_SPLIT2[15][2] = {
  {1u, 2305843009213693952u},
  {5955668970331000884u, 1784059615882449851u},
  {8982663654677661702u, 1380349269358112757u},
  {7286864317269821294u, 2135987035920910082u},
  {7005857020398200553u, 1652639921975621497u},
  {17965325103354776697u, 1278668206209430417u},
  {8928596168509315048u, 1978643211784836272u},
  {10075671573058298858u, 1530901034580419511u},
  {597001226353042382u, 1184477304306571148u},
  {1527430471115325346u, 1832889850782397517u},
  {12533209867169019542u, 1418129833677084982u},
  {5577825024675947042u, 2194449627517475473u},
  {11006974540203867551u, 1697873161311732311u},
  {10313493231639821582u, 1313665730009899186u},
  {12701016819766672773u, 2032799256770390445u}};

__constant__ uint32_t const POW5_INV_OFFSETS[19] = {0x54544554,
                                                    0x04055545,
                                                    0x10041000,
                                                    0x00400414,
                                                    0x40010000,
                                                    0x41155555,
                                                    0x00000454,
                                                    0x00010044,
                                                    0x40000000,
                                                    0x44000041,
                                                    0x50454450,
                                                    0x55550054,
                                                    0x51655554,
                                                    0x40004000,
                                                    0x01000001,
                                                    0x00010500,
                                                    0x51515411,
                                                    0x05555554,
                                                    0x00000000};

__constant__ uint64_t const DOUBLE_POW5_SPLIT2[13][2] = {
  {0u, 1152921504606846976u},
  {0u, 1490116119384765625u},
  {1032610780636961552u, 1925929944387235853u},
  {7910200175544436838u, 1244603055572228341u},
  {16941905809032713930u, 1608611746708759036u},
  {13024893955298202172u, 2079081953128979843u},
  {6607496772837067824u, 1343575221513417750u},
  {17332926989895652603u, 1736530273035216783u},
  {13037379183483547984u, 2244412773384604712u},
  {1605989338741628675u, 1450417759929778918u},
  {9630225068416591280u, 1874621017369538693u},
  {665883850346957067u, 1211445438634777304u},
  {14931890668723713708u, 1565756531257009982u}};

__constant__ uint32_t const POW5_OFFSETS[21] = {
  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x40000000, 0x59695995, 0x55545555,
  0x56555515, 0x41150504, 0x40555410, 0x44555145, 0x44504540, 0x45555550, 0x40004000,
  0x96440440, 0x55565565, 0x54454045, 0x40154151, 0x55559155, 0x51405555, 0x00000105};

constexpr uint32_t POW5_TABLE_SIZE = 26;

__constant__ uint64_t const DOUBLE_POW5_TABLE[POW5_TABLE_SIZE] = {1ull,
                                                                  5ull,
                                                                  25ull,
                                                                  125ull,
                                                                  625ull,
                                                                  3125ull,
                                                                  15625ull,
                                                                  78125ull,
                                                                  390625ull,
                                                                  1953125ull,
                                                                  9765625ull,
                                                                  48828125ull,
                                                                  244140625ull,
                                                                  1220703125ull,
                                                                  6103515625ull,
                                                                  30517578125ull,
                                                                  152587890625ull,
                                                                  762939453125ull,
                                                                  3814697265625ull,
                                                                  19073486328125ull,
                                                                  95367431640625ull,
                                                                  476837158203125ull,
                                                                  2384185791015625ull,
                                                                  11920928955078125ull,
                                                                  59604644775390625ull,
                                                                  298023223876953125ull};

//===== common.h from ryu =====

// Returns the number of decimal digits in v, which must not contain more than 9/17 digits.
template <typename T>
__device__ inline uint32_t decimal_length(T const v)
{
  static_assert(std::is_integral_v<T> && !std::is_signed_v<T>);
  if constexpr (sizeof(T) == sizeof(int64_t)) {
    // The average output length is 16.38 digits, so we check high-to-low.
    // Function precondition: v is not an 18, 19, or 20-digit number.
    // (17 digits are sufficient for round-tripping.)
    assert(v < 100000000000000000L);
    if (v >= 10000000000000000L) { return 17; }
    if (v >= 1000000000000000L) { return 16; }
    if (v >= 100000000000000L) { return 15; }
    if (v >= 10000000000000L) { return 14; }
    if (v >= 1000000000000L) { return 13; }
    if (v >= 100000000000L) { return 12; }
    if (v >= 10000000000L) { return 11; }
    if (v >= 1000000000L) { return 10; }
  }
  // Function precondition: v is not a 10-digit number.
  // (f2s: 9 digits are sufficient for round-tripping.)
  // (d2fixed: We print 9-digit blocks.)
  assert(v < 1000000000);
  if (v >= 100000000) { return 9; }
  if (v >= 10000000) { return 8; }
  if (v >= 1000000) { return 7; }
  if (v >= 100000) { return 6; }
  if (v >= 10000) { return 5; }
  if (v >= 1000) { return 4; }
  if (v >= 100) { return 3; }
  if (v >= 10) { return 2; }
  return 1;
}

// Returns e == 0 ? 1 : ceil(log_2(5^e)); requires 0 <= e <= 3528.
__device__ inline int32_t pow5bits(int32_t const e)
{
  // This approximation works up to the point that the multiplication overflows at e = 3529.
  // If the multiplication were done in 64 bits, it would fail at 5^4004 which is just greater
  // than 2^9297.
  assert(e >= 0);
  assert(e <= 3528);
  return static_cast<int32_t>((((static_cast<uint32_t>(e)) * 1217359) >> 19) + 1);
}

// Returns floor(log_10(2^e)); requires 0 <= e <= 1650.
__device__ inline uint32_t log10Pow2(int32_t const e)
{
  // The first value this approximation fails for is 2^1651 which is just greater than 10^297.
  assert(e >= 0);
  assert(e <= 1650);
  return ((static_cast<uint32_t>(e)) * 78913) >> 18;
}

// Returns floor(log_10(5^e)); requires 0 <= e <= 2620.
__device__ inline uint32_t log10Pow5(int32_t const e)
{
  // The first value this approximation fails for is 5^2621 which is just greater than 10^1832.
  assert(e >= 0);
  assert(e <= 2620);
  return (static_cast<uint32_t>(e) * 732923) >> 20;
}

__device__ inline uint32_t pow5factor_32(uint32_t value)
{
  uint32_t count = 0;
  for (;;) {
    assert(value != 0);
    uint32_t const q = value / 5;
    uint32_t const r = value % 5;
    if (r != 0) { break; }
    value = q;
    ++count;
  }
  return count;
}

// Returns true if value is divisible by 5^p.
__device__ inline bool multipleOfPowerOf5_32(uint32_t const value, uint32_t const p)
{
  return pow5factor_32(value) >= p;
}

// Returns true if value is divisible by 2^p.
__device__ inline bool multipleOfPowerOf2_32(uint32_t const value, uint32_t const p)
{
  // __builtin_ctz doesn't appear to be faster here.
  return (value & ((1u << p) - 1)) == 0;
}

// It seems to be slightly faster to avoid uint128_t here, although the
// generated code for uint128_t looks slightly nicer.
__device__ inline uint32_t mulShift32(uint32_t const m, uint64_t const factor, int32_t const shift)
{
  assert(shift > 32);

  // The casts here help MSVC to avoid calls to the __allmul library
  // function.
  uint32_t const factorLo = static_cast<uint32_t>(factor);
  uint32_t const factorHi = static_cast<uint32_t>(factor >> 32);
  uint64_t const bits0    = static_cast<uint64_t>(m) * factorLo;
  uint64_t const bits1    = static_cast<uint64_t>(m) * factorHi;

  uint64_t const sum        = (bits0 >> 32) + bits1;
  uint64_t const shiftedSum = sum >> (shift - 32);
  assert(shiftedSum <= UINT32_MAX);
  return static_cast<uint32_t>(shiftedSum);
}

__device__ inline int copy_special_str(char* const result,
                                       bool const sign,
                                       bool const exponent,
                                       bool const mantissa)
{
  if (mantissa) {
    memcpy(result, "NaN", 3);
    return 3;
  }
  if (sign) { result[0] = '-'; }
  if (exponent) {
    memcpy(result + sign, "Infinity", 8);
    return sign + 8;
  }
  memcpy(result + sign, "0.0", 3);
  return sign + 3;
}

__device__ inline int special_str_size(bool const sign, bool const exponent, bool const mantissa)
{
  if (mantissa) { return 3; }
  if (exponent) { return sign + 8; }
  return sign + 3;
}

__device__ inline uint32_t float_to_bits(float const f)
{
  uint32_t bits = 0;
  memcpy(&bits, &f, sizeof(float));
  return bits;
}

__device__ inline uint64_t double_to_bits(double const d)
{
  uint64_t bits = 0;
  memcpy(&bits, &d, sizeof(double));
  return bits;
}

//===== d2s_intrinsics.h from ryu =====

__device__ inline uint64_t umul128(uint64_t const a, uint64_t const b, uint64_t* const productHi)
{
  // The casts here help MSVC to avoid calls to the __allmul library function.
  uint32_t const aLo = static_cast<uint32_t>(a);
  uint32_t const aHi = static_cast<uint32_t>(a >> 32);
  uint32_t const bLo = static_cast<uint32_t>(b);
  uint32_t const bHi = static_cast<uint32_t>(b >> 32);

  uint64_t const b00 = static_cast<uint64_t>(aLo) * bLo;
  uint64_t const b01 = static_cast<uint64_t>(aLo) * bHi;
  uint64_t const b10 = static_cast<uint64_t>(aHi) * bLo;
  uint64_t const b11 = static_cast<uint64_t>(aHi) * bHi;

  uint32_t const b00Lo = static_cast<uint32_t>(b00);
  uint32_t const b00Hi = static_cast<uint32_t>(b00 >> 32);

  uint64_t const mid1   = b10 + b00Hi;
  uint32_t const mid1Lo = static_cast<uint32_t>(mid1);
  uint32_t const mid1Hi = static_cast<uint32_t>(mid1 >> 32);

  uint64_t const mid2   = b01 + mid1Lo;
  uint32_t const mid2Lo = static_cast<uint32_t>(mid2);
  uint32_t const mid2Hi = static_cast<uint32_t>(mid2 >> 32);

  uint64_t const pHi = b11 + mid1Hi + mid2Hi;
  uint64_t const pLo = (static_cast<uint64_t>(mid2Lo) << 32) | b00Lo;

  *productHi = pHi;
  return pLo;
}

__device__ inline uint64_t shiftright128(uint64_t const lo, uint64_t const hi, uint32_t const dist)
{
  // We don't need to handle the case dist >= 64 here (see above).
  assert(dist < 64);
  assert(dist > 0);
  return (hi << (64 - dist)) | (lo >> dist);
}

__device__ inline uint64_t div5(uint64_t const x) { return x / 5; }

__device__ inline uint64_t div10(uint64_t const x) { return x / 10; }

__device__ inline uint64_t div100(uint64_t const x) { return x / 100; }

__device__ inline uint32_t pow5Factor(uint64_t value)
{
  uint64_t const m_inv_5 = 14757395258967641293u;  // 5 * m_inv_5 = 1 (mod 2^64)
  uint64_t const n_div_5 = 3689348814741910323u;   // #{ n | n = 0 (mod 2^64) } = 2^64 / 5
  uint32_t count         = 0;
  for (;;) {
    assert(value != 0);
    value *= m_inv_5;
    if (value > n_div_5) break;
    ++count;
  }
  return count;
}

// Returns true if value is divisible by 5^p.
__device__ inline bool multipleOfPowerOf5(uint64_t const value, uint32_t const p)
{
  // I tried a case distinction on p, but there was no performance difference.
  return pow5Factor(value) >= p;
}

// Returns true if value is divisible by 2^p.
__device__ inline bool multipleOfPowerOf2(uint64_t const value, uint32_t const p)
{
  assert(value != 0);
  assert(p < 64);
  // __builtin_ctzll doesn't appear to be faster here.
  return (value & ((1ull << p) - 1)) == 0;
}

__device__ inline uint64_t mulShift64(uint64_t const m, uint64_t const* const mul, int32_t const j)
{
  // m is maximum 55 bits
  uint64_t high1;                                    // 128
  uint64_t const low1 = umul128(m, mul[1], &high1);  // 64
  uint64_t high0;                                    // 64
  umul128(m, mul[0], &high0);                        // 0
  uint64_t const sum = high0 + low1;
  if (sum < high0) {
    ++high1;  // overflow into high1
  }
  return shiftright128(sum, high1, j - 64);
}

__device__ inline uint64_t mulShiftAll64(uint64_t const m,
                                         uint64_t const* const mul,
                                         int32_t const j,
                                         uint64_t* const vp,
                                         uint64_t* const vm,
                                         uint32_t const mmShift)
{
  *vp = mulShift64(4 * m + 2, mul, j);
  *vm = mulShift64(4 * m - 1 - mmShift, mul, j);
  return mulShift64(4 * m, mul, j);
}

//===== d2s_small_table.h from ryu =====

// Computes 5^i in the form required by Ryu, and stores it in the given pointer.
__device__ inline void double_computePow5(uint32_t const i, uint64_t* const result)
{
  uint32_t const base       = i / POW5_TABLE_SIZE;
  uint32_t const base2      = base * POW5_TABLE_SIZE;
  uint32_t const offset     = i - base2;
  uint64_t const* const mul = DOUBLE_POW5_SPLIT2[base];
  if (offset == 0) {
    result[0] = mul[0];
    result[1] = mul[1];
    return;
  }
  uint64_t const m = DOUBLE_POW5_TABLE[offset];
  uint64_t high1;
  uint64_t const low1 = umul128(m, mul[1], &high1);
  uint64_t high0;
  uint64_t const low0 = umul128(m, mul[0], &high0);
  uint64_t const sum  = high0 + low1;
  if (sum < high0) {
    ++high1;  // overflow into high1
  }
  // high1 | sum | low0
  uint32_t const delta = pow5bits(i) - pow5bits(base2);
  result[0] = shiftright128(low0, sum, delta) + ((POW5_OFFSETS[i / 16] >> ((i % 16) << 1)) & 3);
  result[1] = shiftright128(sum, high1, delta);
}

// Computes 5^-i in the form required by Ryu, and stores it in the given pointer.
__device__ inline void double_computeInvPow5(uint32_t const i, uint64_t* const result)
{
  uint32_t const base       = (i + POW5_TABLE_SIZE - 1) / POW5_TABLE_SIZE;
  uint32_t const base2      = base * POW5_TABLE_SIZE;
  uint32_t const offset     = base2 - i;
  uint64_t const* const mul = DOUBLE_POW5_INV_SPLIT2[base];  // 1/5^base2
  if (offset == 0) {
    result[0] = mul[0];
    result[1] = mul[1];
    return;
  }
  uint64_t const m = DOUBLE_POW5_TABLE[offset];
  uint64_t high1;
  uint64_t const low1 = umul128(m, mul[1], &high1);
  uint64_t high0;
  uint64_t const low0 = umul128(m, mul[0] - 1, &high0);
  uint64_t const sum  = high0 + low1;
  if (sum < high0) {
    ++high1;  // overflow into high1
  }
  // high1 | sum | low0
  uint32_t const delta = pow5bits(base2) - pow5bits(i);
  result[0] =
    shiftright128(low0, sum, delta) + 1 + ((POW5_INV_OFFSETS[i / 16] >> ((i % 16) << 1)) & 3);
  result[1] = shiftright128(sum, high1, delta);
}

//===== f2s_intrinsics.h from ryu =====

__device__ inline uint32_t mulPow5InvDivPow2(uint32_t const m, uint32_t const q, int32_t const j)
{
  // The inverse multipliers are defined as [2^x / 5^y] + 1; the upper 64 bits from the double
  // lookup table are the correct bits for [2^x / 5^y], so we have to add 1 here. Note that we rely
  // on the fact that the added 1 that's already stored in the table never overflows into the upper
  // 64 bits.
  uint64_t pow5[2];
  double_computeInvPow5(q, pow5);
  return mulShift32(m, pow5[1] + 1, j);
}

__device__ inline uint32_t mulPow5divPow2(uint32_t const m, uint32_t const i, int32_t const j)
{
  uint64_t pow5[2];
  double_computePow5(i, pow5);
  return mulShift32(m, pow5[1], j);
}

//===== d2s.c and f2s.c from ryu =====

__device__ inline floating_decimal_64 d2d(uint64_t const ieeeMantissa, uint32_t const ieeeExponent)
{
  int32_t e2;
  uint64_t m2;
  if (ieeeExponent == 0) {
    // We subtract 2 so that the bounds computation has 2 additional bits.
    e2 = static_cast<int32_t>(1 - DOUBLE_BIAS - DOUBLE_MANTISSA_BITS - 2);
    m2 = ieeeMantissa;
  } else {
    e2 = static_cast<int32_t>(ieeeExponent) - DOUBLE_BIAS - DOUBLE_MANTISSA_BITS - 2;
    m2 = (1ull << DOUBLE_MANTISSA_BITS) | ieeeMantissa;
  }
  bool const even         = (m2 & 1) == 0;
  bool const acceptBounds = even;

  // Step 2: Determine the interval of valid decimal representations.
  uint64_t const mv = 4 * m2;
  // Implicit bool -> int conversion. True is 1, false is 0.
  uint32_t const mmShift = ieeeMantissa != 0 || ieeeExponent <= 1;
  // We would compute mp and mm like this:
  // uint64_t mp = 4 * m2 + 2;
  // uint64_t mm = mv - 1 - mmShift;

  // Step 3: Convert to a decimal power base using 128-bit arithmetic.
  uint64_t vr, vp, vm;
  int32_t e10;
  bool vmIsTrailingZeros = false;
  bool vrIsTrailingZeros = false;
  if (e2 >= 0) {
    // I tried special-casing q == 0, but there was no effect on performance.
    // This expression is slightly faster than max(0, log10Pow2(e2) - 1).
    uint32_t const q = log10Pow2(e2) - (e2 > 3);
    e10              = static_cast<int32_t>(q);
    int32_t const k  = DOUBLE_POW5_INV_BITCOUNT + pow5bits(static_cast<int32_t>(q)) - 1;
    int32_t const i  = -e2 + static_cast<int32_t>(q) + k;
    uint64_t pow5[2];
    double_computeInvPow5(q, pow5);
    vr = mulShiftAll64(m2, pow5, i, &vp, &vm, mmShift);

    if (q <= 21) {
      // This should use q <= 22, but I think 21 is also safe. Smaller values
      // may still be safe, but it's more difficult to reason about them.
      // Only one of mp, mv, and mm can be a multiple of 5, if any.
      uint32_t const mvMod5 = (static_cast<uint32_t>(mv)) - 5 * (static_cast<uint32_t>(div5(mv)));
      if (mvMod5 == 0) {
        vrIsTrailingZeros = multipleOfPowerOf5(mv, q);
      } else if (acceptBounds) {
        // Same as min(e2 + (~mm & 1), pow5Factor(mm)) >= q
        // <=> e2 + (~mm & 1) >= q && pow5Factor(mm) >= q
        // <=> true && pow5Factor(mm) >= q, since e2 >= q.
        vmIsTrailingZeros = multipleOfPowerOf5(mv - 1 - mmShift, q);
      } else {
        // Same as min(e2 + 1, pow5Factor(mp)) >= q.
        vp -= multipleOfPowerOf5(mv + 2, q);
      }
    }
  } else {
    // This expression is slightly faster than max(0, log10Pow5(-e2) - 1).
    uint32_t const q = log10Pow5(-e2) - (-e2 > 1);
    e10              = static_cast<int32_t>(q) + e2;
    int32_t const i  = -e2 - static_cast<int32_t>(q);
    int32_t const k  = pow5bits(i) - DOUBLE_POW5_BITCOUNT;
    int32_t const j  = static_cast<int32_t>(q) - k;

    uint64_t pow5[2];
    double_computePow5(i, pow5);
    vr = mulShiftAll64(m2, pow5, j, &vp, &vm, mmShift);

    if (q <= 1) {
      // {vr,vp,vm} is trailing zeros if {mv,mp,mm} has at least q trailing 0 bits.
      // mv = 4 * m2, so it always has at least two trailing 0 bits.
      vrIsTrailingZeros = true;
      if (acceptBounds) {
        // mm = mv - 1 - mmShift, so it has 1 trailing 0 bit iff mmShift == 1.
        vmIsTrailingZeros = mmShift == 1;
      } else {
        // mp = mv + 2, so it always has at least one trailing 0 bit.
        --vp;
      }
    } else if (q < 63) {  // TODO(ulfjack): Use a tighter bound here.
      // We want to know if the full product has at least q trailing zeros.
      // We need to compute min(p2(mv), p5(mv) - e2) >= q
      // <=> p2(mv) >= q && p5(mv) - e2 >= q
      // <=> p2(mv) >= q (because -e2 >= q)
      vrIsTrailingZeros = multipleOfPowerOf2(mv, q);
    }
  }

  // Step 4: Find the shortest decimal representation in the interval of valid representations.
  int32_t removed          = 0;
  uint8_t lastRemovedDigit = 0;
  uint64_t output;
  // On average, we remove ~2 digits.
  if (vmIsTrailingZeros || vrIsTrailingZeros) {
    // General case, which happens rarely (~0.7%).
    for (;;) {
      uint64_t const vpDiv10 = div10(vp);
      uint64_t const vmDiv10 = div10(vm);
      if (vpDiv10 <= vmDiv10) { break; }
      uint32_t const vmMod10 = (static_cast<uint32_t>(vm)) - 10 * (static_cast<uint32_t>(vmDiv10));
      uint64_t const vrDiv10 = div10(vr);
      uint32_t const vrMod10 = (static_cast<uint32_t>(vr)) - 10 * (static_cast<uint32_t>(vrDiv10));
      vmIsTrailingZeros &= vmMod10 == 0;
      vrIsTrailingZeros &= lastRemovedDigit == 0;
      lastRemovedDigit = static_cast<uint8_t>(vrMod10);
      vr               = vrDiv10;
      vp               = vpDiv10;
      vm               = vmDiv10;
      ++removed;
    }

    if (vmIsTrailingZeros) {
      for (;;) {
        uint64_t const vmDiv10 = div10(vm);
        uint32_t const vmMod10 =
          (static_cast<uint32_t>(vm)) - 10 * (static_cast<uint32_t>(vmDiv10));
        if (vmMod10 != 0) { break; }
        uint64_t const vpDiv10 = div10(vp);
        uint64_t const vrDiv10 = div10(vr);
        uint32_t const vrMod10 =
          (static_cast<uint32_t>(vr)) - 10 * (static_cast<uint32_t>(vrDiv10));
        vrIsTrailingZeros &= lastRemovedDigit == 0;
        lastRemovedDigit = static_cast<uint8_t>(vrMod10);
        vr               = vrDiv10;
        vp               = vpDiv10;
        vm               = vmDiv10;
        ++removed;
      }
    }

    if (vrIsTrailingZeros && lastRemovedDigit == 5 && vr % 2 == 0) {
      // Round even if the exact number is .....50..0.
      lastRemovedDigit = 4;
    }
    // We need to take vr + 1 if vr is outside bounds or we need to round up.
    output = vr + ((vr == vm && (!acceptBounds || !vmIsTrailingZeros)) || lastRemovedDigit >= 5);
  } else {
    // Specialized for the common case (~99.3%). Percentages below are relative to this.
    bool roundUp            = false;
    uint64_t const vpDiv100 = div100(vp);
    uint64_t const vmDiv100 = div100(vm);
    if (vpDiv100 > vmDiv100) {  // Optimization: remove two digits at a time (~86.2%).
      uint64_t const vrDiv100 = div100(vr);
      uint32_t const vrMod100 =
        (static_cast<uint32_t>(vr)) - 100 * (static_cast<uint32_t>(vrDiv100));
      roundUp = vrMod100 >= 50;
      vr      = vrDiv100;
      vp      = vpDiv100;
      vm      = vmDiv100;
      removed += 2;
    }
    // Loop iterations below (approximately), without optimization above:
    // 0: 0.03%, 1: 13.8%, 2: 70.6%, 3: 14.0%, 4: 1.40%, 5: 0.14%, 6+: 0.02%
    // Loop iterations below (approximately), with optimization above:
    // 0: 70.6%, 1: 27.8%, 2: 1.40%, 3: 0.14%, 4+: 0.02%
    for (;;) {
      uint64_t const vpDiv10 = div10(vp);
      uint64_t const vmDiv10 = div10(vm);
      if (vpDiv10 <= vmDiv10) { break; }
      uint64_t const vrDiv10 = div10(vr);
      uint32_t const vrMod10 = (static_cast<uint32_t>(vr)) - 10 * (static_cast<uint32_t>(vrDiv10));
      roundUp                = vrMod10 >= 5;
      vr                     = vrDiv10;
      vp                     = vpDiv10;
      vm                     = vmDiv10;
      ++removed;
    }

    // We need to take vr + 1 if vr is outside bounds or we need to round up.
    output = vr + (vr == vm || roundUp);
  }
  int32_t const exp = e10 + removed;

  floating_decimal_64 fd;
  fd.exponent = exp;
  fd.mantissa = output;
  return fd;
}

__device__ inline floating_decimal_32 f2d(uint32_t const ieeeMantissa, uint32_t const ieeeExponent)
{
  int32_t e2;
  uint32_t m2;
  if (ieeeExponent == 0) {
    // We subtract 2 so that the bounds computation has 2 additional bits.
    e2 = static_cast<int32_t>(1 - FLOAT_BIAS - FLOAT_MANTISSA_BITS - 2);
    m2 = ieeeMantissa;
  } else {
    e2 = static_cast<int32_t>(ieeeExponent) - FLOAT_BIAS - FLOAT_MANTISSA_BITS - 2;
    m2 = (1u << FLOAT_MANTISSA_BITS) | ieeeMantissa;
  }
  bool const even         = (m2 & 1) == 0;
  bool const acceptBounds = even;

  // Step 2: Determine the interval of valid decimal representations.
  uint32_t const mv = 4 * m2;
  uint32_t const mp = 4 * m2 + 2;
  // Implicit bool -> int conversion. True is 1, false is 0.
  uint32_t const mmShift = ieeeMantissa != 0 || ieeeExponent <= 1;
  uint32_t const mm      = 4 * m2 - 1 - mmShift;

  // Step 3: Convert to a decimal power base using 64-bit arithmetic.
  uint32_t vr, vp, vm;
  int32_t e10;
  bool vmIsTrailingZeros   = false;
  bool vrIsTrailingZeros   = false;
  uint8_t lastRemovedDigit = 0;
  if (e2 >= 0) {
    uint32_t const q = log10Pow2(e2);
    e10              = static_cast<int32_t>(q);
    int32_t const k  = FLOAT_POW5_INV_BITCOUNT + pow5bits(static_cast<int32_t>(q)) - 1;
    int32_t const i  = -e2 + static_cast<int32_t>(q) + k;
    vr               = mulPow5InvDivPow2(mv, q, i);
    vp               = mulPow5InvDivPow2(mp, q, i);
    vm               = mulPow5InvDivPow2(mm, q, i);
    if (q != 0 && (vp - 1) / 10 <= vm / 10) {
      // We need to know one removed digit even if we are not going to loop below. We could use
      // q = X - 1 above, except that would require 33 bits for the result, and we've found that
      // 32-bit arithmetic is faster even on 64-bit machines.
      int32_t const l  = FLOAT_POW5_INV_BITCOUNT + pow5bits(static_cast<int32_t>(q - 1)) - 1;
      lastRemovedDigit = static_cast<uint8_t>(
        mulPow5InvDivPow2(mv, q - 1, -e2 + static_cast<int32_t>(q) - 1 + l) % 10);
    }
    if (q <= 9) {
      // The largest power of 5 that fits in 24 bits is 5^10, but q <= 9 seems to be safe as well.
      // Only one of mp, mv, and mm can be a multiple of 5, if any.
      if (mv % 5 == 0) {
        vrIsTrailingZeros = multipleOfPowerOf5_32(mv, q);
      } else if (acceptBounds) {
        vmIsTrailingZeros = multipleOfPowerOf5_32(mm, q);
      } else {
        vp -= multipleOfPowerOf5_32(mp, q);
      }
    }
  } else {
    uint32_t const q = log10Pow5(-e2);
    e10              = static_cast<int32_t>(q) + e2;
    int32_t const i  = -e2 - static_cast<int32_t>(q);
    int32_t const k  = pow5bits(i) - FLOAT_POW5_BITCOUNT;
    int32_t j        = static_cast<int32_t>(q) - k;
    vr               = mulPow5divPow2(mv, static_cast<uint32_t>(i), j);
    vp               = mulPow5divPow2(mp, static_cast<uint32_t>(i), j);
    vm               = mulPow5divPow2(mm, static_cast<uint32_t>(i), j);
    if (q != 0 && (vp - 1) / 10 <= vm / 10) {
      j = static_cast<int32_t>(q) - 1 - (pow5bits(i + 1) - FLOAT_POW5_BITCOUNT);
      lastRemovedDigit =
        static_cast<uint8_t>(mulPow5divPow2(mv, static_cast<uint32_t>(i + 1), j) % 10);
    }
    if (q <= 1) {
      // {vr,vp,vm} is trailing zeros if {mv,mp,mm} has at least q trailing 0 bits.
      // mv = 4 * m2, so it always has at least two trailing 0 bits.
      vrIsTrailingZeros = true;
      if (acceptBounds) {
        // mm = mv - 1 - mmShift, so it has 1 trailing 0 bit iff mmShift == 1.
        vmIsTrailingZeros = mmShift == 1;
      } else {
        // mp = mv + 2, so it always has at least one trailing 0 bit.
        --vp;
      }
    } else if (q < 31) {  // TODO(ulfjack): Use a tighter bound here.
      vrIsTrailingZeros = multipleOfPowerOf2_32(mv, q - 1);
    }
  }

  // Step 4: Find the shortest decimal representation in the interval of valid representations.
  int32_t removed = 0;
  uint32_t output;
  if (vmIsTrailingZeros || vrIsTrailingZeros) {
    // General case, which happens rarely (~4.0%).
    while (vp / 10 > vm / 10) {
      vmIsTrailingZeros &= vm % 10 == 0;
      vrIsTrailingZeros &= lastRemovedDigit == 0;
      lastRemovedDigit = static_cast<uint8_t>(vr % 10);
      vr /= 10;
      vp /= 10;
      vm /= 10;
      ++removed;
    }
    if (vmIsTrailingZeros) {
      while (vm % 10 == 0) {
        vrIsTrailingZeros &= lastRemovedDigit == 0;
        lastRemovedDigit = static_cast<uint8_t>(vr % 10);
        vr /= 10;
        vp /= 10;
        vm /= 10;
        ++removed;
      }
    }
    if (vrIsTrailingZeros && lastRemovedDigit == 5 && vr % 2 == 0) {
      // Round even if the exact number is .....50..0.
      lastRemovedDigit = 4;
    }
    // We need to take vr + 1 if vr is outside bounds or we need to round up.
    output = vr + ((vr == vm && (!acceptBounds || !vmIsTrailingZeros)) || lastRemovedDigit >= 5);
  } else {
    // Specialized for the common case (~96.0%). Percentages below are relative to this.
    // Loop iterations below (approximately):
    // 0: 13.6%, 1: 70.7%, 2: 14.1%, 3: 1.39%, 4: 0.14%, 5+: 0.01%
    while (vp / 10 > vm / 10) {
      lastRemovedDigit = static_cast<uint8_t>(vr % 10);
      vr /= 10;
      vp /= 10;
      vm /= 10;
      ++removed;
    }
    // We need to take vr + 1 if vr is outside bounds or we need to round up.
    output = vr + (vr == vm || lastRemovedDigit >= 5);
  }
  int32_t const exp = e10 + removed;

  floating_decimal_32 fd;
  fd.exponent = exp;
  fd.mantissa = output;
  return fd;
}

__device__ inline int to_chars(floating_decimal_64 const v, bool const sign, char* const result)
{
  // Step 5: Print the decimal representation.
  int index = 0;
  if (sign) { result[index++] = '-'; }

  uint64_t output         = v.mantissa;
  uint32_t const olength  = decimal_length(output);
  int32_t exp             = v.exponent + static_cast<int32_t>(olength) - 1;
  bool scientificNotation = (exp < -3) || (exp >= 7);

  // Values in the interval [1E-3, 1E7) are special.
  if (scientificNotation) {
    // Print in the format x.xxxxxE-yy.
    for (uint32_t i = 0; i < olength - 1; ++i) {
      uint32_t const c = output % 10;
      output /= 10;
      result[index + olength - i] = (char)('0' + c);
    }
    result[index]     = '0' + output % 10;
    result[index + 1] = '.';
    index += olength + 1;
    if (olength == 1) { result[index++] = '0'; }
    // Print 'E', the exponent sign, and the exponent, which has at most three digits.
    result[index++] = 'E';
    if (exp < 0) {
      result[index++] = '-';
      exp             = -exp;
    }
    if (exp >= 100) {
      result[index++] = (char)('0' + exp / 100);
      exp %= 100;
      result[index++] = (char)('0' + exp / 10);
    } else if (exp >= 10) {
      result[index++] = (char)('0' + exp / 10);
    }
    result[index++] = (char)('0' + exp % 10);
  } else {
    // Otherwise follow the Java spec for values in the interval [1E-3, 1E7).
    if (exp < 0) {
      // Decimal dot is before any of the digits.
      result[index++] = '0';
      result[index++] = '.';
      for (int i = -1; i > exp; i--) {
        result[index++] = '0';
      }
      int current = index;
      for (int i = 0; i < olength; i++) {
        result[current + olength - i - 1] = (char)('0' + output % 10);
        output /= 10;
        index++;
      }
    } else if (exp + 1 >= olength) {
      // Decimal dot is after any of the digits.
      for (int i = 0; i < olength; i++) {
        result[index + olength - i - 1] = (char)('0' + output % 10);
        output /= 10;
      }
      index += olength;
      for (int i = olength; i < exp + 1; i++) {
        result[index++] = '0';
      }
      result[index++] = '.';
      result[index++] = '0';
    } else {
      // Decimal dot is somewhere between the digits.
      int current = index + 1;
      for (int i = 0; i < olength; i++) {
        if (olength - i - 1 == exp) {
          result[current + olength - i - 1] = '.';
          current--;
        }
        result[current + olength - i - 1] = (char)('0' + output % 10);
        output /= 10;
      }
      index += olength + 1;
    }
  }
  return index;
}

__device__ inline int d2s_size(floating_decimal_64 const v, bool const sign)
{
  int index = 0;
  if (sign) { index++; }

  uint64_t output         = v.mantissa;
  uint32_t const olength  = decimal_length(output);
  int32_t exp             = v.exponent + static_cast<int32_t>(olength) - 1;
  bool scientificNotation = (exp < -3) || (exp >= 7);

  if (scientificNotation) {
    index += olength + 1;
    if (olength == 1) { index++; }
    // 'E'
    index++;
    if (exp < 0) {
      exp = -exp;
      index++;
    }
    if (exp >= 100) {
      index += 3;
    } else if (exp >= 10) {
      index += 2;
    } else {
      index++;
    }
  } else {
    // Otherwise follow the Java spec for values in the interval [1E-3, 1E7).
    if (exp < 0) {
      index += 1 - exp + olength;
    } else if (exp + 1 >= olength) {
      index += exp + 3;
    } else {
      index += olength + 1;
    }
  }
  return index;
}

__device__ inline int to_chars(floating_decimal_32 const v, bool const sign, char* const result)
{
  // Step 5: Print the decimal representation.
  int index = 0;
  if (sign) { result[index++] = '-'; }

  uint32_t output         = v.mantissa;
  uint32_t const olength  = decimal_length(output);
  int32_t exp             = v.exponent + olength - 1;
  bool scientificNotation = (exp < -3) || (exp >= 7);

  if (scientificNotation) {
    // Print in the format x.xxxxxE-yy.
    for (int i = 0; i < olength - 1; i++) {
      int c = output % 10;
      output /= 10;
      result[index + olength - i] = (char)('0' + c);
    }
    result[index]     = (char)('0' + output % 10);
    result[index + 1] = '.';
    index += olength + 1;
    if (olength == 1) { result[index++] = '0'; }

    // Print 'E', the exponent sign, and the exponent, which has at most two digits.
    result[index++] = 'E';
    if (exp < 0) {
      result[index++] = '-';
      exp             = -exp;
    }
    if (exp >= 10) { result[index++] = (char)('0' + exp / 10); }
    result[index++] = (char)('0' + exp % 10);
  } else {
    // Otherwise follow the Java spec for values in the interval [1E-3, 1E7).
    if (exp < 0) {
      // Decimal dot is before any of the digits.
      result[index++] = '0';
      result[index++] = '.';
      for (int i = -1; i > exp; i--) {
        result[index++] = '0';
      }
      int current = index;
      for (int i = 0; i < olength; i++) {
        result[current + olength - i - 1] = (char)('0' + output % 10);
        output /= 10;
        index++;
      }
    } else if (exp + 1 >= olength) {
      // Decimal dot is after any of the digits.
      for (int i = 0; i < olength; i++) {
        result[index + olength - i - 1] = (char)('0' + output % 10);
        output /= 10;
      }
      index += olength;
      for (int i = olength; i < exp + 1; i++) {
        result[index++] = '0';
      }
      result[index++] = '.';
      result[index++] = '0';
    } else {
      // Decimal dot is somewhere between the digits.
      int current = index + 1;
      for (int i = 0; i < olength; i++) {
        if (olength - i - 1 == exp) {
          result[current + olength - i - 1] = '.';
          current--;
        }
        result[current + olength - i - 1] = (char)('0' + output % 10);
        output /= 10;
      }
      index += olength + 1;
    }
  }
  return index;
}

__device__ inline int f2s_size(floating_decimal_32 const v, bool const sign)
{
  // Step 5: Print the decimal representation.
  int index = 0;
  if (sign) { index++; }

  uint32_t output         = v.mantissa;
  uint32_t const olength  = decimal_length(output);
  int32_t exp             = v.exponent + olength - 1;
  bool scientificNotation = (exp < -3) || (exp >= 7);

  if (scientificNotation) {
    index += olength + 1;
    if (olength == 1) { index++; }
    // 'E'
    index++;
    if (exp < 0) {
      index++;
      exp = -exp;
    }
    if (exp >= 10) { index++; }
    index++;
  } else {
    // Otherwise follow the Java spec for values in the interval [1E-3, 1E7).
    if (exp < 0) {
      // Decimal dot is before any of the digits.
      index += 1 - exp + olength;
    } else if (exp + 1 >= olength) {
      // Decimal dot is after any of the digits.
      index += exp + 3;
    } else {
      // Decimal dot is somewhere between the digits.
      index += olength + 1;
    }
  }
  return index;
}

__device__ inline bool d2d_small_int(uint64_t const ieeeMantissa,
                                     uint32_t const ieeeExponent,
                                     floating_decimal_64* const v)
{
  uint64_t const m2 = (1ull << DOUBLE_MANTISSA_BITS) | ieeeMantissa;
  int32_t const e2  = static_cast<int32_t>(ieeeExponent) - DOUBLE_BIAS - DOUBLE_MANTISSA_BITS;

  if (e2 > 0) {
    // f = m2 * 2^e2 >= 2^53 is an integer.
    // Ignore this case for now.
    return false;
  }

  if (e2 < -52) {
    // f < 1.
    return false;
  }

  // Since 2^52 <= m2 < 2^53 and 0 <= -e2 <= 52: 1 <= f = m2 / 2^-e2 < 2^53.
  // Test if the lower -e2 bits of the significand are 0, i.e. whether the fraction is 0.
  uint64_t const mask     = (1ull << -e2) - 1;
  uint64_t const fraction = m2 & mask;
  if (fraction != 0) { return false; }

  // f is an integer in the range [1, 2^53).
  // Note: mantissa might contain trailing (decimal) 0's.
  // Note: since 2^53 < 10^16, there is no need to adjust decimal_length().
  v->mantissa = m2 >> -e2;
  v->exponent = 0;
  return true;
}

__device__ inline floating_decimal_64 d2d(double f, bool& ieeeSign, bool& special)
{
  // Step 1: Decode the floating-point number, and unify normalized and subnormal cases.
  uint64_t const bits = double_to_bits(f);

  // Decode bits into sign, mantissa, and exponent.
  ieeeSign                    = ((bits >> (DOUBLE_MANTISSA_BITS + DOUBLE_EXPONENT_BITS)) & 1) != 0;
  uint64_t const ieeeMantissa = bits & ((1ull << DOUBLE_MANTISSA_BITS) - 1);
  uint32_t const ieeeExponent =
    static_cast<uint32_t>((bits >> DOUBLE_MANTISSA_BITS) & ((1u << DOUBLE_EXPONENT_BITS) - 1));
  // Case distinction; exit early for the easy cases.
  if (ieeeExponent == ((1u << DOUBLE_EXPONENT_BITS) - 1u) ||
      (ieeeExponent == 0 && ieeeMantissa == 0)) {
    special = true;
    return floating_decimal_64{ieeeMantissa, static_cast<int32_t>(ieeeExponent)};
  }
  special = false;
  floating_decimal_64 v;
  bool const isSmallInt = d2d_small_int(ieeeMantissa, ieeeExponent, &v);
  if (isSmallInt) {
    // For small integers in the range [1, 2^53), v.mantissa might contain trailing (decimal) zeros.
    // For scientific notation we need to move these zeros into the exponent.
    // (This is not needed for fixed-point notation, so it might be beneficial to trim
    // trailing zeros in to_chars only if needed - once fixed-point notation output is implemented.)
    for (;;) {
      uint64_t const q = div10(v.mantissa);
      uint32_t const r = (static_cast<uint32_t>(v.mantissa)) - 10 * (static_cast<uint32_t>(q));
      if (r != 0) { break; }
      v.mantissa = q;
      ++v.exponent;
    }
  } else {
    v = d2d(ieeeMantissa, ieeeExponent);
  }
  return v;
}

__device__ inline int d2s_buffered_n(double f, char* result)
{
  bool sign = false, special = false;
  floating_decimal_64 v = d2d(f, sign, special);
  if (special) { return copy_special_str(result, sign, v.exponent, v.mantissa); }
  return to_chars(v, sign, result);
}

__device__ inline floating_decimal_32 f2d(float f, bool& ieeeSign, bool& special)
{
  // Step 1: Decode the floating-point number, and unify normalized and subnormal cases.
  uint32_t const bits = float_to_bits(f);

  // Decode bits into sign, mantissa, and exponent.
  ieeeSign                    = ((bits >> (FLOAT_MANTISSA_BITS + FLOAT_EXPONENT_BITS)) & 1) != 0;
  uint32_t const ieeeMantissa = bits & ((1u << FLOAT_MANTISSA_BITS) - 1);
  uint32_t const ieeeExponent = (bits >> FLOAT_MANTISSA_BITS) & ((1u << FLOAT_EXPONENT_BITS) - 1);

  // Case distinction; exit early for the easy cases.
  if (ieeeExponent == ((1u << FLOAT_EXPONENT_BITS) - 1u) ||
      (ieeeExponent == 0 && ieeeMantissa == 0)) {
    special = true;
    return floating_decimal_32{ieeeMantissa, static_cast<int32_t>(ieeeExponent)};
  }
  special = false;
  return f2d(ieeeMantissa, ieeeExponent);
}

__device__ inline int f2s_buffered_n(float f, char* result)
{
  bool sign = false, special = false;
  floating_decimal_32 v = f2d(f, sign, special);
  if (special) { return copy_special_str(result, sign, v.exponent, v.mantissa); }
  return to_chars(v, sign, result);
}

//===== compute float to string size =====

__device__ inline int compute_d2s_size(double value)
{
  bool sign = false, special = false;
  floating_decimal_64 v = d2d(value, sign, special);
  if (special) { return special_str_size(sign, v.exponent, v.mantissa); }
  return d2s_size(v, sign);
}

__device__ inline int compute_f2s_size(float value)
{
  bool sign = false, special = false;
  floating_decimal_32 v = f2d(value, sign, special);
  if (special) { return special_str_size(sign, v.exponent, v.mantissa); }
  return f2s_size(v, sign);
}

}  // namespace

//===== APIs =====

__device__ inline int compute_ftos_size(double value, bool is_float)
{
  if (is_float) {
    return compute_f2s_size(value);
  } else {
    return compute_d2s_size(value);
  }
}

__device__ inline int float_to_string(double value, bool is_float, char* output)
{
  if (is_float) {
    return f2s_buffered_n(value, output);
  } else {
    return d2s_buffered_n(value, output);
  }
}

//===== format float =====

__constant__ uint64_t const POW10_TABLE[19] = {1ull,
                                               10ull,
                                               100ull,
                                               1000ull,
                                               10000ull,
                                               100000ull,
                                               1000000ull,
                                               10000000ull,
                                               100000000ull,
                                               1000000000ull,
                                               10000000000ull,
                                               100000000000ull,
                                               1000000000000ull,
                                               10000000000000ull,
                                               100000000000000ull,
                                               1000000000000000ull,
                                               10000000000000000ull,
                                               100000000000000000ull};

template <typename T>
__device__ inline T round_half_even(T const input, int const olength, int const digits)
{
  // "round" a integer to digits digits, with the half-even rounding mode.
  if (digits > olength) {
    // trailing zeros will be handled later
    return input;
  }
  T div = POW10_TABLE[olength - digits];
  T mod = input % div;
  T num = input / div;
  if (mod > (div / 2) || ((mod == (div / 2) && (num % 2 == 1) && mod != 0))) { num++; }
  return num;
}

/*
 * Convert a floating_decimal_32/64 to a formatted string as the default format (#,###,###.##)
 * of format_number in Spark.
 *
 * @param v The input floating_decimal_32/64 value
 * @param sign Sign of the number
 * @param result Output string
 * @param digits Number of digits after decimal point
 */
template <typename T>
__device__ inline int to_formatted_chars(T const v, bool const sign, char* const result, int digits)
{
  static_assert(std::is_same_v<T, floating_decimal_32> || std::is_same_v<T, floating_decimal_64>);
  using U   = std::conditional_t<std::is_same_v<T, floating_decimal_32>, uint32_t, uint64_t>;
  int index = 0;
  if (sign) { result[index++] = '-'; }
  U output               = v.mantissa;
  uint32_t const olength = decimal_length(output);
  int32_t exp            = v.exponent + static_cast<int32_t>(olength) - 1;
  if (exp < 0) {
    // Decimal dot is before any of the digits.
    int index_for_carrier = index;
    result[index++]       = '0';
    if (digits == 0) { return index; }
    result[index++]  = '.';
    int actual_round = digits;
    for (int i = -1; i > exp; i--) {
      index_for_carrier = index;
      result[index++]   = '0';
      actual_round--;
      if (actual_round == 0) {
        if (i != exp + 1) { return index; }  // else, possible carry
        break;
      }
    }
    int actual_olength = fmin(int(olength), actual_round);
    U rounded_output   = round_half_even(output, olength, actual_round);
    // check if carry
    if (rounded_output >= POW10_TABLE[actual_olength]) {
      result[index_for_carrier] = '1';
      rounded_output -= POW10_TABLE[actual_olength];
    }
    int current = index;
    for (int i = 0; i < actual_olength; i++) {
      result[current + actual_olength - i - 1] = (char)('0' + rounded_output % 10);
      rounded_output /= 10;
      index++;
    }
    actual_round -= actual_olength;
    if (actual_round > 0) {
      for (int i = 0; i < actual_round; i++) {
        result[index++] = '0';
      }
    }
  } else if (exp + 1 >= olength) {
    // Decimal dot is after any of the digits.
    int integer_len = index + exp + 1 + exp / 3;
    int sep_cnt     = 0;
    int rev_index   = 0;
    for (int i = olength; i < exp + 1; i++) {
      result[integer_len - (rev_index++) - 1] = '0';
      sep_cnt++;
      if (sep_cnt == 3) {
        result[integer_len - (rev_index++) - 1] = ',';
        sep_cnt                                 = 0;
      }
    }
    for (int i = 0; i < olength; i++) {
      if (sep_cnt == 3) {
        result[integer_len - (rev_index++) - 1] = ',';
        sep_cnt                                 = 0;
      }
      result[integer_len - (rev_index++) - 1] = (char)('0' + output % 10);
      sep_cnt++;
      output /= 10;
    }
    index = integer_len;
    if (digits == 0) { return index; }
    result[index++] = '.';
    for (int i = 0; i < digits; i++) {
      result[index++] = '0';
    }
  } else {
    // 0 <= exp < olength - 1
    uint32_t temp_d = digits, tailing_zero = 0;
    if (exp + digits + 1 > olength) {
      temp_d       = olength - exp - 1;
      tailing_zero = digits - temp_d;
    }
    U rounded_output = round_half_even(output, olength, exp + temp_d + 1);
    U pow10          = POW10_TABLE[temp_d];
    U integer        = rounded_output / pow10;
    U decimal        = rounded_output % pow10;
    // calculate integer length after format to cover carry case
    uint32_t integer_len          = decimal_length(integer);
    uint32_t formated_integer_len = index + integer_len + (integer_len - 1) / 3;
    uint32_t sep_cnt              = 0;
    int rev_index                 = 0;
    for (int i = 0; i < integer_len; i++) {
      if (sep_cnt == 3) {
        result[formated_integer_len - (rev_index++) - 1] = ',';
        sep_cnt                                          = 0;
      }
      result[formated_integer_len - (rev_index++) - 1] = (char)('0' + integer % 10);
      sep_cnt++;
      integer /= 10;
    }
    index = formated_integer_len;
    if (digits == 0) { return index; }
    result[index++] = '.';
    int current     = index;
    for (int i = 0; i < tailing_zero; i++) {
      result[current + digits - i - 1] = '0';
      index++;
    }
    for (int i = tailing_zero; i < digits; i++) {
      result[current + digits - i - 1] = (char)('0' + decimal % 10);
      decimal /= 10;
      index++;
    }
  }
  return index;
}

template <typename T>
__device__ inline int format_size(T const v, bool const sign, int digits)
{
  static_assert(std::is_same_v<T, floating_decimal_32> || std::is_same_v<T, floating_decimal_64>);
  using U   = std::conditional_t<std::is_same_v<T, floating_decimal_32>, uint32_t, uint64_t>;
  int index = 0;
  if (sign) { index++; }
  U output               = v.mantissa;
  uint32_t const olength = decimal_length(output);
  int32_t exp            = v.exponent + static_cast<int32_t>(olength) - 1;
  if (exp < 0) {
    index += 2 + digits;
  } else if (exp + 1 >= olength) {
    index += exp + 1 + exp / 3 + 1 + digits;
  } else {
    uint32_t temp_d = digits;
    if (exp + digits + 1 > olength) { temp_d = olength - exp - 1; }
    U rounded_output     = round_half_even(output, olength, exp + temp_d + 1);
    U pow10              = POW10_TABLE[temp_d];
    U integer            = rounded_output / pow10;
    uint32_t integer_len = decimal_length(integer);
    index += integer_len + (integer_len - 1) / 3 + 1 + digits;
  }
  if (digits == 0) { index--; }
  return index;
}

__device__ inline int copy_format_special_str(char* const result,
                                              bool const sign,
                                              bool const exponent,
                                              bool const mantissa,
                                              int const digits = 1)
{
  if (mantissa) {
    memcpy(result, "\xEF\xBF\xBD", 3);  // U+FFFD, replacement character, NaN
    return 3;
  }
  if (sign) { result[0] = '-'; }
  if (exponent) {
    memcpy(result + sign, "\xE2\x88\x9E", 3);  // U+221E, infinity symbol
    return sign + 3;
  }
  result[sign] = '0';
  if (digits == 0) {
    return sign + 1;
  } else {
    result[sign + 1] = '.';
  }
  for (int i = 0; i < digits; i++) {
    result[sign + 2 + i] = '0';
  }
  return sign + 2 + digits;
}

__device__ inline int special_format_str_size(bool const sign,
                                              bool const exponent,
                                              bool const mantissa,
                                              int const digits = 1)
{
  if (mantissa) { return 3; }
  if (exponent) { return sign + 3; }
  if (digits == 0) { return sign + 1; }
  return sign + 2 + digits;
}

__device__ inline int compute_format_float_size(double value, int digits, bool is_float)
{
  bool sign = false, special = false;
  if (is_float) {
    floating_decimal_32 v = f2d(value, sign, special);
    if (special) { return special_format_str_size(sign, v.exponent, v.mantissa, digits); }
    return format_size<floating_decimal_32>(v, sign, digits);
  } else {
    floating_decimal_64 v = d2d(value, sign, special);
    if (special) { return special_format_str_size(sign, v.exponent, v.mantissa, digits); }
    return format_size<floating_decimal_64>(v, sign, digits);
  }
}

__device__ inline int format_float(double value, int digits, bool is_float, char* output)
{
  bool sign = false, special = false;
  if (is_float) {
    floating_decimal_32 v = f2d(value, sign, special);
    if (special) { return copy_format_special_str(output, sign, v.exponent, v.mantissa, digits); }
    return to_formatted_chars<floating_decimal_32>(v, sign, output, digits);
  } else {
    floating_decimal_64 v = d2d(value, sign, special);
    if (special) { return copy_format_special_str(output, sign, v.exponent, v.mantissa, digits); }
    return to_formatted_chars<floating_decimal_64>(v, sign, output, digits);
  }
}

}  // namespace spark_rapids_jni::ftos_converter
